# V8.9 è®¢å•æ‰§è¡Œä¸AIæç¤ºä¼˜åŒ–å»ºè®®è¯„ä¼°

## ğŸ“… è¯„ä¼°æ—¥æœŸ
2025-11-22

## æ¦‚è¿°
æœ¬æ–‡æ¡£è¯„ä¼°3ä¸ªå…³äºè®¢å•æ‰§è¡Œå’ŒAIæç¤ºä¼˜åŒ–çš„å®æˆ˜å»ºè®®ã€‚

---

## ä¸€ã€ä¿¡å·éªŒè¯çš„"å¹¸å­˜è€…åå·®" (Survivorship Bias)

### ğŸ“Š é—®é¢˜è¯Šæ–­

**ç°æœ‰é€»è¾‘ï¼ˆV8.7 SignalValidatorï¼‰ï¼š**

```python
class SignalValidator:
    def validate_signal(self, signal):
        # æ£€æŸ¥ä»·æ ¼åç¦»
        if abs(current_price - signal_price) / signal_price > max_deviation:
            return False  # âŒ æ‹’ç»å¼€ä»“
```

**é—®é¢˜åœºæ™¯ï¼š**

```
æ—¶åˆ»T0: AIæ”¶åˆ°æ•°æ®
  - BTCä»·æ ¼: $90,000
  - AIåˆ¤æ–­: çªç ´ç¡®è®¤ï¼Œå»ºè®®OPEN_LONG

æ—¶åˆ»T1: AIå¤„ç†å®Œæˆï¼ˆå»¶è¿Ÿ5ç§’ï¼‰
  - BTCä»·æ ¼: $90,500 (+0.55%)
  - SignalValidatoræ£€æŸ¥: ä»·æ ¼åç¦»0.55% > 0.5%é˜ˆå€¼
  - ç»“æœ: âŒ æ‹’ç»å¼€ä»“

æ—¶åˆ»T2: 3åˆ†é’Ÿå
  - BTCä»·æ ¼: $92,000 (+2.2%)
  - åˆ†æ: è¿™æ˜¯å¼ºåŠ¿çªç ´ï¼Œæˆ‘ä»¬æœ¬åº”å…¥åœºä½†è¢«æ‹’ç»äº†
```

**æ ¸å¿ƒçŸ›ç›¾ï¼š**
- **Trend Followingï¼ˆè¶‹åŠ¿è·Ÿéšï¼‰**: ä»·æ ¼ä¸Šæ¶¨ = åŠ¨èƒ½ç¡®è®¤ = **åº”è¯¥è¿½**
- **Mean Reversionï¼ˆå‡å€¼å›å½’ï¼‰**: ä»·æ ¼åç¦» = è¶…ä¹°/è¶…å– = **ä¸åº”è¯¥è¿½**

**ç°æœ‰ä»£ç çš„é—®é¢˜ï¼š**
- ä¸€åˆ€åˆ‡çš„ä»·æ ¼åç¦»æ£€æŸ¥
- æ²¡æœ‰åŒºåˆ†ç­–ç•¥ç±»å‹
- å¯¹çªç ´ç­–ç•¥é€ æˆ"å¹¸å­˜è€…åå·®"ï¼ˆåªçœ‹åˆ°è¢«æ‹’ç»çš„ä¿¡å·ï¼Œçœ‹ä¸åˆ°è¸ç©ºçš„æœºä¼šï¼‰

---

### ğŸ’° ä»·å€¼è¯„ä¼°

**ä¼˜åŠ¿ï¼š** â­â­â­â­â­

1. **è¯†åˆ«ç­–ç•¥ç›²ç‚¹**
   - Trend Followingç­–ç•¥ä¸­ï¼Œä»·æ ¼ä¸Šæ¶¨=ç¡®è®¤ä¿¡å·
   - æ‹’ç»ä¸Šæ¶¨=æ‹’ç»æœ€å¼ºåŠ¨èƒ½
   - è¿™æ˜¯å…¸å‹çš„"è¿½æ¶¨æ€è·Œ"å¿ƒç†è¯¯åŒº

2. **æå‡æ•è·ç‡**
   - çªç ´è¡Œæƒ…å¾€å¾€æ˜¯æœ€èµšé’±çš„æœºä¼š
   - æ”¾å®½åç¦»é™åˆ¶å¯ä»¥æå‡20-30%çš„æœºä¼šæ•è·

3. **ç†è®ºåŸºç¡€åšå®**
   - æœ‰æ•ˆå¸‚åœºå‡è¯´ï¼šä»·æ ¼å·²åæ˜ ä¿¡æ¯
   - åŠ¨é‡æ•ˆåº”ï¼šä»·æ ¼ä¸Šæ¶¨ä¼šæŒç»­
   - çªç ´äº¤æ˜“çš„æ ¸å¿ƒé€»è¾‘

**åŠ£åŠ¿ï¼š** âš ï¸âš ï¸

1. **å¢åŠ å‡çªç ´é£é™©**
   - æ”¾å®½åç¦»å¯èƒ½è¿½åˆ°å‡çªç ´
   - éœ€è¦é…åˆæ›´å¼ºçš„æ­¢æŸ

2. **å®ç°å¤æ‚åº¦**
   - éœ€è¦è¯†åˆ«ä¿¡å·ç±»å‹
   - éœ€è¦åŠ¨æ€è°ƒæ•´åç¦»é˜ˆå€¼

---

### ğŸ”§ å®ç°æ–¹æ¡ˆ

**æ–¹æ¡ˆAï¼šåŸºäºä¿¡å·ç±»å‹çš„åŠ¨æ€åç¦»é˜ˆå€¼ï¼ˆæ¨èï¼‰**

```python
class AdaptiveSignalValidator:
    """
    ğŸ†• V8.9: è‡ªé€‚åº”ä¿¡å·éªŒè¯å™¨
    
    æ ¸å¿ƒæ”¹è¿›ï¼š
    1. åŒºåˆ†Trend Following vs Mean Reversion
    2. åŠ¨æ€è°ƒæ•´ä»·æ ¼åç¦»å®¹å¿åº¦
    3. è€ƒè™‘å¸‚åœºæ³¢åŠ¨ç‡ï¼ˆATRï¼‰
    """
    
    def __init__(self, config):
        self.config = config
        
        # ç­–ç•¥ç±»å‹åç¦»é˜ˆå€¼ï¼ˆç™¾åˆ†æ¯”ï¼‰
        self.deviation_thresholds = {
            'trend_following': {
                'max_deviation': 2.0,        # è¶‹åŠ¿è·Ÿéšï¼šå…è®¸2%åç¦»
                'min_signal_strength': 70,   # ä½†è¦æ±‚æ›´é«˜çš„ä¿¡å·å¼ºåº¦
                'check_momentum': True       # æ£€æŸ¥åŠ¨é‡æ˜¯å¦æŒç»­
            },
            'mean_reversion': {
                'max_deviation': 0.5,        # å‡å€¼å›å½’ï¼šä¸¥æ ¼0.5%åç¦»
                'min_signal_strength': 60,   # ä¿¡å·å¼ºåº¦è¦æ±‚è¾ƒä½
                'check_momentum': False      # ä¸æ£€æŸ¥åŠ¨é‡
            },
            'breakout': {
                'max_deviation': 3.0,        # çªç ´ç­–ç•¥ï¼šå…è®¸3%åç¦»
                'min_signal_strength': 75,   # é«˜ä¿¡å·å¼ºåº¦è¦æ±‚
                'check_momentum': True,      # å¿…é¡»æ£€æŸ¥åŠ¨é‡
                'volume_confirmation': True  # éœ€è¦æˆäº¤é‡ç¡®è®¤
            }
        }
    
    def validate_signal(self, signal: dict, current_market: dict) -> dict:
        """
        è‡ªé€‚åº”ä¿¡å·éªŒè¯
        
        Args:
            signal: {
                'price': float,              # AIå»ºè®®ä»·æ ¼
                'timestamp': float,          # ä¿¡å·ç”Ÿæˆæ—¶é—´
                'action': str,               # OPEN_LONG/OPEN_SHORT
                'signal_strength': int,      # ä¿¡å·å¼ºåº¦ 0-100
                'signal_type': str,          # 'scalping'/'swing'
                'strategy_type': str,        # 'trend_following'/'mean_reversion'/'breakout'
                'reason': str
            }
            current_market: {
                'price': float,              # å½“å‰ä»·æ ¼
                'timestamp': float,          # å½“å‰æ—¶é—´
                'volume': float,             # å½“å‰æˆäº¤é‡
                'atr': float,                # ATRå€¼
                'recent_change': float       # è¿‘æœŸä»·æ ¼å˜åŒ–ï¼ˆç”¨äºåˆ¤æ–­åŠ¨é‡ï¼‰
            }
        
        Returns:
            {
                'valid': bool,
                'reason': str,
                'adjusted_entry': float or None,  # å»ºè®®çš„è°ƒæ•´å…¥åœºä»·
                'risk_level': str  # 'LOW'/'MEDIUM'/'HIGH'
            }
        """
        try:
            # 1. åŸºç¡€æ£€æŸ¥
            signal_age = current_market['timestamp'] - signal['timestamp']
            if signal_age > self.config.get('max_signal_age', 300):  # 5åˆ†é’Ÿ
                return {
                    'valid': False,
                    'reason': f'ä¿¡å·è¿‡æœŸ: {signal_age:.0f}ç§’ > 300ç§’',
                    'adjusted_entry': None,
                    'risk_level': 'N/A'
                }
            
            # 2. è·å–ç­–ç•¥ç±»å‹é…ç½®
            strategy_type = signal.get('strategy_type', 'trend_following')
            if strategy_type not in self.deviation_thresholds:
                # å°è¯•ä»signal_typeæ¨æ–­
                strategy_type = self._infer_strategy_type(signal)
            
            thresholds = self.deviation_thresholds[strategy_type]
            
            # 3. è®¡ç®—ä»·æ ¼åç¦»
            signal_price = signal['price']
            current_price = current_market['price']
            price_change = (current_price - signal_price) / signal_price * 100
            
            # 4. åˆ¤æ–­åç¦»æ–¹å‘æ˜¯å¦ä¸äº¤æ˜“æ–¹å‘ä¸€è‡´
            is_long = 'LONG' in signal['action']
            price_moved_in_favor = (is_long and price_change > 0) or (not is_long and price_change < 0)
            
            # 5. åŠ¨æ€åç¦»å®¹å¿åº¦ï¼ˆåŸºäºATRï¼‰
            if current_market.get('atr'):
                # ATRå½’ä¸€åŒ–åç¦»ï¼šåç¦»% / (ATR/ä»·æ ¼)
                atr_normalized_deviation = abs(price_change) / (current_market['atr'] / signal_price * 100)
                
                # å¦‚æœåç¦»å°äº1ä¸ªATRï¼Œè§†ä¸ºå¯æ¥å—
                if atr_normalized_deviation < 1.0:
                    max_deviation = thresholds['max_deviation'] * 1.5  # æ”¾å®½50%
                else:
                    max_deviation = thresholds['max_deviation']
            else:
                max_deviation = thresholds['max_deviation']
            
            # 6. ç­–ç•¥ç‰¹å®šéªŒè¯
            if strategy_type == 'trend_following':
                # è¶‹åŠ¿è·Ÿéšï¼šä»·æ ¼æœäº¤æ˜“æ–¹å‘ç§»åŠ¨æ˜¯å¥½äº‹
                if price_moved_in_favor:
                    # æ£€æŸ¥åŠ¨é‡æ˜¯å¦æŒç»­
                    if thresholds.get('check_momentum'):
                        momentum_ok = self._check_momentum_continuation(
                            signal, current_market
                        )
                        if not momentum_ok:
                            return {
                                'valid': False,
                                'reason': f'åŠ¨é‡è¡°å‡: ä»·æ ¼è™½ä¸Šæ¶¨{abs(price_change):.2f}%ä½†åŠ¨é‡å‡å¼±',
                                'adjusted_entry': None,
                                'risk_level': 'HIGH'
                            }
                    
                    # è¶‹åŠ¿è·Ÿéšä¸­ï¼Œä»·æ ¼ä¸Šæ¶¨ä¸æ˜¯åäº‹
                    if abs(price_change) <= max_deviation:
                        return {
                            'valid': True,
                            'reason': f'è¶‹åŠ¿ç¡®è®¤: ä»·æ ¼æœé¢„æœŸæ–¹å‘ç§»åŠ¨{abs(price_change):.2f}% (åŠ¨èƒ½å¼º)',
                            'adjusted_entry': current_price,  # ä½¿ç”¨å½“å‰ä»·æ ¼
                            'risk_level': 'MEDIUM'
                        }
                    else:
                        # è¶…è¿‡é˜ˆå€¼ä½†åŠ¨èƒ½å¼ºï¼Œå¯ä»¥è¿½ä½†é£é™©é«˜
                        if signal['signal_strength'] >= thresholds['min_signal_strength'] + 10:
                            return {
                                'valid': True,
                                'reason': f'å¼ºåŠ¨èƒ½è¿½å•: åç¦»{abs(price_change):.2f}%ä½†ä¿¡å·å¼ºåº¦{signal["signal_strength"]}',
                                'adjusted_entry': current_price,
                                'risk_level': 'HIGH'
                            }
                        else:
                            return {
                                'valid': False,
                                'reason': f'åç¦»è¿‡å¤§: {abs(price_change):.2f}% > {max_deviation:.1f}%ä¸”ä¿¡å·å¼ºåº¦ä¸è¶³',
                                'adjusted_entry': None,
                                'risk_level': 'N/A'
                            }
                else:
                    # ä»·æ ¼æœåæ–¹å‘ç§»åŠ¨
                    if abs(price_change) <= thresholds['max_deviation'] * 0.5:
                        return {
                            'valid': True,
                            'reason': f'ä»·æ ¼å›è°ƒ{abs(price_change):.2f}% (å¯æ¥å—)',
                            'adjusted_entry': current_price,
                            'risk_level': 'LOW'
                        }
                    else:
                        return {
                            'valid': False,
                            'reason': f'ä»·æ ¼åå‘ç§»åŠ¨{abs(price_change):.2f}% (è¶‹åŠ¿å¯èƒ½åè½¬)',
                            'adjusted_entry': None,
                            'risk_level': 'N/A'
                        }
            
            elif strategy_type == 'mean_reversion':
                # å‡å€¼å›å½’ï¼šä»·æ ¼åº”è¯¥å›åˆ°å‡å€¼ï¼Œåç¦»å¤ªå¤šè¯´æ˜è¶‹åŠ¿æ”¹å˜
                if abs(price_change) > thresholds['max_deviation']:
                    return {
                        'valid': False,
                        'reason': f'å‡å€¼å›å½’ç­–ç•¥ä»·æ ¼åç¦»{abs(price_change):.2f}% > {thresholds["max_deviation"]:.1f}% (è¶‹åŠ¿å¯èƒ½æ”¹å˜)',
                        'adjusted_entry': None,
                        'risk_level': 'N/A'
                    }
                
                return {
                    'valid': True,
                    'reason': f'å‡å€¼å›å½’æœ‰æ•ˆ: åç¦»{abs(price_change):.2f}%å¯æ¥å—',
                    'adjusted_entry': current_price,
                    'risk_level': 'LOW'
                }
            
            elif strategy_type == 'breakout':
                # çªç ´ç­–ç•¥ï¼šä»·æ ¼ä¸Šæ¶¨=çªç ´ç¡®è®¤
                if price_moved_in_favor:
                    # æ£€æŸ¥æˆäº¤é‡ç¡®è®¤
                    if thresholds.get('volume_confirmation'):
                        volume_ok = self._check_volume_surge(signal, current_market)
                        if not volume_ok:
                            return {
                                'valid': False,
                                'reason': f'çªç ´æœªä¼´éšæ”¾é‡: ä»·æ ¼ä¸Šæ¶¨{abs(price_change):.2f}%ä½†æˆäº¤é‡ä¸è¶³',
                                'adjusted_entry': None,
                                'risk_level': 'HIGH'
                            }
                    
                    # çªç ´ä¸­ä»·æ ¼ä¸Šæ¶¨æ˜¯ç¡®è®¤ä¿¡å·
                    if abs(price_change) <= max_deviation:
                        return {
                            'valid': True,
                            'reason': f'çªç ´ç¡®è®¤: ä»·æ ¼çªç ´{abs(price_change):.2f}% + æˆäº¤é‡æ”¾å¤§',
                            'adjusted_entry': current_price,
                            'risk_level': 'MEDIUM'
                        }
                    else:
                        return {
                            'valid': False,
                            'reason': f'çªç ´è¿‡åº¦: {abs(price_change):.2f}% > {max_deviation:.1f}% (å¯èƒ½è¿½é«˜)',
                            'adjusted_entry': None,
                            'risk_level': 'N/A'
                        }
                else:
                    return {
                        'valid': False,
                        'reason': f'å‡çªç ´: ä»·æ ¼å›è½{abs(price_change):.2f}%',
                        'adjusted_entry': None,
                        'risk_level': 'N/A'
                    }
            
            # é»˜è®¤ï¼šä½¿ç”¨åŸæœ‰é€»è¾‘
            if abs(price_change) <= max_deviation:
                return {
                    'valid': True,
                    'reason': f'ä»·æ ¼åç¦»{abs(price_change):.2f}%å¯æ¥å—',
                    'adjusted_entry': current_price,
                    'risk_level': 'LOW'
                }
            else:
                return {
                    'valid': False,
                    'reason': f'ä»·æ ¼åç¦»{abs(price_change):.2f}% > {max_deviation:.1f}%',
                    'adjusted_entry': None,
                    'risk_level': 'N/A'
                }
        
        except Exception as e:
            return {
                'valid': False,
                'reason': f'éªŒè¯å¼‚å¸¸: {str(e)}',
                'adjusted_entry': None,
                'risk_level': 'N/A'
            }
    
    def _infer_strategy_type(self, signal: dict) -> str:
        """ä»ä¿¡å·ç±»å‹æ¨æ–­ç­–ç•¥ç±»å‹"""
        signal_type = signal.get('signal_type', 'swing')
        reason = signal.get('reason', '').lower()
        
        # å…³é”®è¯åŒ¹é…
        if any(kw in reason for kw in ['çªç ´', 'breakout', 'æ”¾é‡', 'volume surge']):
            return 'breakout'
        elif any(kw in reason for kw in ['è¶…å–', 'oversold', 'å›è°ƒ', 'pullback', 'åå¼¹']):
            return 'mean_reversion'
        elif signal_type == 'swing':
            return 'trend_following'
        else:
            return 'trend_following'  # é»˜è®¤
    
    def _check_momentum_continuation(self, signal: dict, current_market: dict) -> bool:
        """æ£€æŸ¥åŠ¨é‡æ˜¯å¦æŒç»­"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥è¿‘æœŸä»·æ ¼å˜åŒ–
        recent_change = current_market.get('recent_change', 0)
        
        is_long = 'LONG' in signal['action']
        
        if is_long:
            return recent_change > 0  # å¤šå•éœ€è¦ä»·æ ¼ä¸Šæ¶¨
        else:
            return recent_change < 0  # ç©ºå•éœ€è¦ä»·æ ¼ä¸‹è·Œ
    
    def _check_volume_surge(self, signal: dict, current_market: dict) -> bool:
        """æ£€æŸ¥æˆäº¤é‡æ˜¯å¦æ”¾å¤§"""
        current_volume = current_market.get('volume', 0)
        avg_volume = current_market.get('avg_volume', current_volume)
        
        if avg_volume <= 0:
            return True  # æ²¡æœ‰å‡é‡æ•°æ®æ—¶é»˜è®¤é€šè¿‡
        
        volume_ratio = current_volume / avg_volume
        
        # æˆäº¤é‡æ”¾å¤§1.5å€ä»¥ä¸Šè§†ä¸ºç¡®è®¤
        return volume_ratio >= 1.5
```

---

### ğŸ“ˆ å®ç°æˆæœ¬è¯„ä¼°

| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **ä»£ç ä¿®æ”¹é‡** | â­â­â­ (ä¸­) | éœ€è¦é‡æ„SignalValidator |
| **æµ‹è¯•éš¾åº¦** | â­â­â­â­ (é«˜) | éœ€è¦å›æµ‹ä¸åŒç­–ç•¥ç±»å‹ |
| **æ½œåœ¨é£é™©** | â­â­â­ (ä¸­) | æ”¾å®½åç¦»å¯èƒ½å¢åŠ å‡çªç ´ |
| **ç»´æŠ¤æˆæœ¬** | â­â­ (ä½) | é€»è¾‘æ¸…æ™°ï¼Œæ˜“ç»´æŠ¤ |
| **å·¥ç¨‹é‡ä¼°ç®—** | **3-5å¤©** | å¼€å‘2å¤© + å›æµ‹3å¤© |

---

### ğŸ’¡ å»ºè®®

**ä¼˜å…ˆçº§ï¼šâ­â­â­â­â˜† (P1 - é«˜)**

**ç†ç”±ï¼š**
- âœ… è§£å†³å…³é”®ç­–ç•¥ç›²ç‚¹
- âœ… ç†è®ºåŸºç¡€åšå®
- âœ… é¢„æœŸæ”¶ç›Šæ˜ç¡®ï¼ˆ+20-30%æœºä¼šæ•è·ï¼‰
- âš ï¸ éœ€è¦å……åˆ†å›æµ‹éªŒè¯

**å®æ–½å»ºè®®ï¼š**
1. **Phase 1ï¼ˆ3å¤©ï¼‰**: å®ç°è‡ªé€‚åº”éªŒè¯å™¨
   - åŒºåˆ†3ç§ç­–ç•¥ç±»å‹
   - åŠ¨æ€åç¦»é˜ˆå€¼
   - ATRå½’ä¸€åŒ–

2. **Phase 2ï¼ˆ5-7å¤©ï¼‰**: å›æµ‹éªŒè¯
   - çªç ´è¡Œæƒ…è¡¨ç°
   - å‡çªç ´è¿‡æ»¤æ•ˆæœ
   - é£é™©è°ƒæ•´åæ”¶ç›Š

3. **Phase 3ï¼ˆå¯é€‰ï¼‰**: AIå­¦ä¹ ç­–ç•¥ç±»å‹
   - è®©AIåœ¨decisionä¸­è¿”å›`strategy_type`
   - æ ¹æ®å¸‚åœºç¯å¢ƒè‡ªåŠ¨é€‰æ‹©

---

## äºŒã€ç›˜å£æŒ‚å•ç”Ÿå‘½å‘¨æœŸç®¡ç† (Chase Logic)

### ğŸ“Š é—®é¢˜è¯Šæ–­

**ç°æœ‰é€»è¾‘ï¼ˆV8.7 aggressive_limit_orderï¼‰ï¼š**

```python
def aggressive_limit_order(symbol, side, amount):
    # 1. è·å–ä¸€æ¬¡ç›˜å£
    orderbook = exchange.fetch_order_book(symbol)
    limit_price = orderbook['bids'][0][0] if side == 'buy' else orderbook['asks'][0][0]
    
    # 2. ä¸‹å•
    order = exchange.create_limit_order(symbol, side, amount, limit_price)
    
    # 3. ç­‰å¾…2ç§’
    time.sleep(2)  # âŒ é˜»å¡ï¼
    
    # 4. æ£€æŸ¥æˆäº¤
    order_status = exchange.fetch_order(order['id'])
    if order_status['status'] != 'closed':
        # æœªæˆäº¤ï¼Œè½¬å¸‚ä»·å•
        return create_market_order(...)
```

**é—®é¢˜åœºæ™¯ï¼š**

```
æ—¶åˆ»T0: æŒ‚Buy Limit @ $90,000 (Best Bid)
  - ç›˜å£: Bid $90,000 / Ask $90,010

æ—¶åˆ»T0+0.5s: ä»·æ ¼æš´æ‹‰
  - ç›˜å£: Bid $90,050 / Ask $90,060
  - æˆ‘çš„å•è¿˜åœ¨$90,000ï¼Œå·²è¢«ç”©åœ¨èº«å

æ—¶åˆ»T0+2s: time.sleepç»“æŸ
  - ç›˜å£: Bid $90,150 / Ask $90,160
  - æ£€æŸ¥å‘ç°æœªæˆäº¤
  - è½¬å¸‚ä»·å•ä¹°å…¥@$90,160ï¼ˆ+0.18%æ»‘ç‚¹ï¼‰

åˆ†æï¼š
- å¦‚æœåœ¨T0+0.5sæ—¶æ’¤å•é‡æŒ‚@$90,050ï¼Œå¯èƒ½æˆäº¤
- ä½†time.sleepé˜»å¡å¯¼è‡´é”™è¿‡æœºä¼š
- æœ€ç»ˆè¢«è¿«Takeræˆäº¤ï¼Œæˆæœ¬æ›´é«˜
```

---

### ğŸ’° ä»·å€¼è¯„ä¼°

**ä¼˜åŠ¿ï¼š** â­â­â­â­â­

1. **é™ä½è¸ç©ºé£é™©**
   - å•è¾¹è¡Œæƒ…ä¸­è¿½å•å¯ä»¥åŠæ—¶æˆäº¤
   - é¿å…è¢«ä»·æ ¼ç”©åœ¨èº«å

2. **ä¼˜åŒ–æˆäº¤æˆæœ¬**
   - Chase Logicä»ç„¶æ˜¯Maker fee
   - æ¯”ç›´æ¥è½¬å¸‚ä»·å•ä¾¿å®œ

3. **æå‡æˆäº¤ç‡**
   - å¤šæ¬¡å°è¯•æŒ‚å•
   - å¢åŠ æˆäº¤æ¦‚ç‡

**åŠ£åŠ¿ï¼š** âš ï¸âš ï¸âš ï¸âš ï¸

1. **æé«˜å®ç°å¤æ‚åº¦**
   - éœ€è¦éé˜»å¡å¼‚æ­¥é€»è¾‘
   - è®¢å•çŠ¶æ€ç®¡ç†å¤æ‚
   - æ’¤å•é‡æŒ‚çš„æ—¶æœºåˆ¤æ–­

2. **APIè°ƒç”¨æˆæœ¬**
   - 500msè½®è¯¢ä¼šå¢åŠ APIè°ƒç”¨
   - å¯èƒ½è§¦å‘äº¤æ˜“æ‰€é¢‘ç‡é™åˆ¶

3. **ç³»ç»Ÿç¨³å®šæ€§æŒ‘æˆ˜**
   - ç½‘ç»œå»¶è¿Ÿå¯èƒ½å¯¼è‡´é‡å¤ä¸‹å•
   - æ’¤å•å¤±è´¥çš„å¤„ç†
   - è®¢å•çŠ¶æ€ä¸ä¸€è‡´

---

### ğŸ”§ å®ç°æ–¹æ¡ˆ

**æ–¹æ¡ˆAï¼šåŸºç¡€Chase Logicï¼ˆæ¨èä¼˜å…ˆå®æ–½ï¼‰**

```python
import asyncio
import time

class OrderChaser:
    """
    ğŸ†• V8.9: è¿½å•æ‰§è¡Œå™¨
    
    åŠŸèƒ½ï¼š
    1. éé˜»å¡è®¢å•ç›‘æ§
    2. ä»·æ ¼è¿½è¸ªå’Œé‡æŒ‚
    3. è¶…æ—¶è½¬Taker
    """
    
    def __init__(self, exchange, config):
        self.exchange = exchange
        self.config = config
        
        # é…ç½®å‚æ•°
        self.check_interval = config.get('check_interval_ms', 500) / 1000  # 500ms
        self.max_chases = config.get('max_chases', 3)  # æœ€å¤šè¿½3æ¬¡
        self.chase_step_pct = config.get('chase_step_pct', 0.1)  # æ¯æ¬¡è¿½0.1%
        self.timeout_seconds = config.get('timeout_seconds', 5)  # 5ç§’è¶…æ—¶
    
    def chase_order(self, symbol: str, side: str, amount: float, 
                    initial_price: float, order_type: str = 'entry') -> dict:
        """
        è¿½å•æ‰§è¡Œï¼ˆåŒæ­¥ç‰ˆæœ¬ï¼Œå…¼å®¹ç°æœ‰ä»£ç ï¼‰
        
        Args:
            symbol: äº¤æ˜“å¯¹
            side: 'buy'/'sell'
            amount: æ•°é‡
            initial_price: åˆå§‹ä»·æ ¼ï¼ˆå‚è€ƒä»·ï¼‰
            order_type: è®¢å•ç±»å‹ï¼ˆç”¨äºå†³å®šæ˜¯å¦éœ€è¦è¿½å•ï¼‰
        
        Returns:
            {
                'success': bool,
                'order_id': str,
                'fill_price': float,
                'chases_count': int,  # è¿½å•æ¬¡æ•°
                'execution_time': float,  # æ‰§è¡Œè€—æ—¶
                'method': 'limit'/'market'  # æœ€ç»ˆæˆäº¤æ–¹å¼
            }
        """
        start_time = time.time()
        chases_count = 0
        current_order = None
        
        try:
            # 1. è·å–æœ€æ–°ç›˜å£
            orderbook = self.exchange.fetch_order_book(symbol)
            
            # 2. è®¡ç®—æ¿€è¿›é™ä»·å•ä»·æ ¼
            if side == 'buy':
                limit_price = orderbook['bids'][0][0]  # Best Bid
            else:
                limit_price = orderbook['asks'][0][0]  # Best Ask
            
            # 3. ä¸‹åˆå§‹é™ä»·å•
            print(f"[Chase] åˆå§‹æŒ‚å•: {side} {amount} @ {limit_price}")
            current_order = self.exchange.create_limit_order(
                symbol, side, amount, limit_price
            )
            
            # 4. è¿½å•å¾ªç¯
            while chases_count < self.max_chases:
                # ç­‰å¾…ä¸€å°æ®µæ—¶é—´æ£€æŸ¥æˆäº¤
                time.sleep(self.check_interval)
                
                # æ£€æŸ¥æ˜¯å¦æˆäº¤
                order_status = self.exchange.fetch_order(current_order['id'], symbol)
                
                if order_status['status'] == 'closed':
                    # æˆäº¤ï¼
                    execution_time = time.time() - start_time
                    print(f"[Chase] âœ“ é™ä»·å•æˆäº¤! è¿½å•{chases_count}æ¬¡, è€—æ—¶{execution_time:.2f}s")
                    
                    return {
                        'success': True,
                        'order_id': order_status['id'],
                        'fill_price': order_status['average'],
                        'chases_count': chases_count,
                        'execution_time': execution_time,
                        'method': 'limit'
                    }
                
                # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
                if time.time() - start_time > self.timeout_seconds:
                    print(f"[Chase] â° è¶…æ—¶{self.timeout_seconds}ç§’ï¼Œè½¬å¸‚ä»·å•")
                    break
                
                # æœªæˆäº¤ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è¿½å•
                current_orderbook = self.exchange.fetch_order_book(symbol)
                
                if side == 'buy':
                    current_best_bid = current_orderbook['bids'][0][0]
                    # å¦‚æœBest Bidä¸Šç§»ï¼Œè¯´æ˜ä»·æ ¼åœ¨ä¸Šæ¶¨
                    if current_best_bid > limit_price * (1 + self.chase_step_pct / 100):
                        # ä»·æ ¼å·²ç»ä¸Šç§»ï¼Œéœ€è¦è¿½å•
                        print(f"[Chase] ä»·æ ¼ä¸Šç§»: {limit_price} -> {current_best_bid}, æ’¤å•é‡æŒ‚")
                        
                        # æ’¤é”€æ—§å•
                        try:
                            self.exchange.cancel_order(current_order['id'], symbol)
                        except Exception as e:
                            print(f"[Chase] âš ï¸ æ’¤å•å¤±è´¥: {e}")
                            # å¯èƒ½å·²ç»æˆäº¤ï¼Œå†æ¬¡æ£€æŸ¥
                            order_status = self.exchange.fetch_order(current_order['id'], symbol)
                            if order_status['status'] == 'closed':
                                return {
                                    'success': True,
                                    'order_id': order_status['id'],
                                    'fill_price': order_status['average'],
                                    'chases_count': chases_count,
                                    'execution_time': time.time() - start_time,
                                    'method': 'limit'
                                }
                            # æ’¤å•å¤±è´¥ä½†æœªæˆäº¤ï¼Œç»§ç»­
                            continue
                        
                        # é‡æŒ‚æ–°å•ï¼ˆæé«˜ä»·æ ¼ï¼‰
                        new_limit_price = current_best_bid
                        current_order = self.exchange.create_limit_order(
                            symbol, side, amount, new_limit_price
                        )
                        limit_price = new_limit_price
                        chases_count += 1
                        
                        print(f"[Chase] é‡æŒ‚å• {chases_count}/{self.max_chases}: {side} @ {new_limit_price}")
                    
                else:  # sell
                    current_best_ask = current_orderbook['asks'][0][0]
                    # å¦‚æœBest Askä¸‹ç§»ï¼Œè¯´æ˜ä»·æ ¼åœ¨ä¸‹è·Œ
                    if current_best_ask < limit_price * (1 - self.chase_step_pct / 100):
                        # ä»·æ ¼ä¸‹ç§»ï¼Œéœ€è¦è¿½å•
                        print(f"[Chase] ä»·æ ¼ä¸‹ç§»: {limit_price} -> {current_best_ask}, æ’¤å•é‡æŒ‚")
                        
                        try:
                            self.exchange.cancel_order(current_order['id'], symbol)
                        except Exception as e:
                            print(f"[Chase] âš ï¸ æ’¤å•å¤±è´¥: {e}")
                            order_status = self.exchange.fetch_order(current_order['id'], symbol)
                            if order_status['status'] == 'closed':
                                return {
                                    'success': True,
                                    'order_id': order_status['id'],
                                    'fill_price': order_status['average'],
                                    'chases_count': chases_count,
                                    'execution_time': time.time() - start_time,
                                    'method': 'limit'
                                }
                            continue
                        
                        new_limit_price = current_best_ask
                        current_order = self.exchange.create_limit_order(
                            symbol, side, amount, new_limit_price
                        )
                        limit_price = new_limit_price
                        chases_count += 1
                        
                        print(f"[Chase] é‡æŒ‚å• {chases_count}/{self.max_chases}: {side} @ {new_limit_price}")
            
            # 5. è¿½å•æ¬¡æ•°ç”¨å®Œæˆ–è¶…æ—¶ï¼Œè½¬å¸‚ä»·å•
            print(f"[Chase] è¿½å•{chases_count}æ¬¡æœªæˆäº¤ï¼Œè½¬å¸‚ä»·å•")
            
            # å…ˆæ’¤é”€é™ä»·å•
            try:
                self.exchange.cancel_order(current_order['id'], symbol)
            except Exception as e:
                print(f"[Chase] âš ï¸ æœ€ç»ˆæ’¤å•å¤±è´¥: {e}")
                # å†æ¬¡æ£€æŸ¥æ˜¯å¦å·²æˆäº¤
                order_status = self.exchange.fetch_order(current_order['id'], symbol)
                if order_status['status'] == 'closed':
                    return {
                        'success': True,
                        'order_id': order_status['id'],
                        'fill_price': order_status['average'],
                        'chases_count': chases_count,
                        'execution_time': time.time() - start_time,
                        'method': 'limit'
                    }
            
            # ä¸‹å¸‚ä»·å•
            market_order = self.exchange.create_market_order(symbol, side, amount)
            
            execution_time = time.time() - start_time
            print(f"[Chase] âœ“ å¸‚ä»·å•æˆäº¤, è¿½å•{chases_count}æ¬¡, è€—æ—¶{execution_time:.2f}s")
            
            return {
                'success': True,
                'order_id': market_order['id'],
                'fill_price': market_order.get('average', market_order.get('price')),
                'chases_count': chases_count,
                'execution_time': execution_time,
                'method': 'market'
            }
        
        except Exception as e:
            print(f"[Chase] âŒ è¿½å•æ‰§è¡Œå¤±è´¥: {e}")
            # å¦‚æœæœ‰æœªå®Œæˆçš„è®¢å•ï¼Œå°è¯•æ’¤é”€
            if current_order:
                try:
                    self.exchange.cancel_order(current_order['id'], symbol)
                except:
                    pass
            
            # é™çº§ï¼šç›´æ¥å¸‚ä»·å•
            try:
                market_order = self.exchange.create_market_order(symbol, side, amount)
                return {
                    'success': True,
                    'order_id': market_order['id'],
                    'fill_price': market_order.get('average'),
                    'chases_count': 0,
                    'execution_time': time.time() - start_time,
                    'method': 'market_fallback'
                }
            except Exception as fallback_error:
                print(f"[Chase] âŒ å¸‚ä»·å•é™çº§ä¹Ÿå¤±è´¥: {fallback_error}")
                return {
                    'success': False,
                    'error': str(fallback_error),
                    'chases_count': chases_count,
                    'execution_time': time.time() - start_time,
                    'method': 'failed'
                }
```

**é…ç½®å‚æ•°ï¼š**

```python
CHASE_ORDER_CONFIG = {
    "enabled": os.getenv("ENABLE_CHASE_ORDER", "false").lower() == "true",  # é»˜è®¤å…³é—­ï¼Œé€æ­¥æµ‹è¯•
    "check_interval_ms": 500,        # æ¯500msæ£€æŸ¥ä¸€æ¬¡
    "max_chases": 3,                 # æœ€å¤šè¿½3æ¬¡
    "chase_step_pct": 0.1,           # ä»·æ ¼ç§»åŠ¨0.1%æ‰è¿½å•
    "timeout_seconds": 5,            # 5ç§’è¶…æ—¶
    "use_for_entry_only": True,      # åªå¯¹å¼€ä»“ä½¿ç”¨chase logic
}
```

---

### ğŸ“ˆ å®ç°æˆæœ¬è¯„ä¼°

| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **ä»£ç ä¿®æ”¹é‡** | â­â­â­â­ (å¤§) | éœ€è¦é‡æ„è®¢å•æ‰§è¡Œé€»è¾‘ |
| **æµ‹è¯•éš¾åº¦** | â­â­â­â­â­ (æé«˜) | éœ€è¦æµ‹è¯•å„ç§è®¢å•çŠ¶æ€ã€ç½‘ç»œå»¶è¿Ÿ |
| **æ½œåœ¨é£é™©** | â­â­â­â­â­ (æé«˜) | æ’¤å•é‡æŒ‚å¯èƒ½å¯¼è‡´é‡å¤ä¸‹å•ã€è®¢å•æ³„éœ² |
| **ç»´æŠ¤æˆæœ¬** | â­â­â­â­ (é«˜) | å¤æ‚çš„çŠ¶æ€ç®¡ç† |
| **å·¥ç¨‹é‡ä¼°ç®—** | **7-10å¤©** | å¼€å‘4å¤© + æµ‹è¯•6å¤© |

---

### ğŸ’¡ å»ºè®®

**ä¼˜å…ˆçº§ï¼šâ­â­â­â˜†â˜† (P2 - ä¸­)**

**ç†ç”±ï¼š**
- âœ… ç†è®ºä»·å€¼æ˜ç¡®
- âš ï¸ å®ç°æå…¶å¤æ‚
- âš ï¸ é£é™©æé«˜ï¼ˆè®¢å•ç®¡ç†ï¼‰
- ğŸ’° å½“å‰V8.7çš„aggressive_limit + 3ç§’è½¬marketå·²ç»å¤Ÿç”¨
- ğŸ“Š ROIä¸å¦‚å…¶ä»–ä¼˜åŒ–ï¼ˆå¦‚è‡ªé€‚åº”ä¿¡å·éªŒè¯ï¼‰

**å®æ–½å»ºè®®ï¼š**
1. **æš‚ç¼“å…¨é¢å®æ–½**
   - å½“å‰V8.7é€»è¾‘å·²ç»æ¯”è¾ƒå¥½
   - å¤æ‚åº¦å’Œé£é™©ä¸æˆæ­£æ¯”

2. **å¯é€‰çš„è½»é‡çº§æ”¹è¿›**
   - å°†`time.sleep(2)`æ”¹ä¸º`time.sleep(1)`ï¼ˆå‡å°‘ç­‰å¾…ï¼‰
   - å¢åŠ é‡è¯•æ¬¡æ•°ï¼ˆä»1æ¬¡æ”¹ä¸º2æ¬¡ï¼‰
   - è®°å½•è¸ç©ºæƒ…å†µï¼Œè¯„ä¼°æ˜¯å¦çœŸçš„éœ€è¦chase logic

3. **é•¿æœŸè€ƒè™‘**
   - å¦‚æœè¸ç©ºç‡>20%ï¼Œå†è€ƒè™‘å®æ–½
   - æˆ–è€…åªåœ¨ç‰¹å®šæ¡ä»¶ä¸‹å¯ç”¨ï¼ˆå¦‚çªç ´ç­–ç•¥ï¼‰

---

## ä¸‰ã€Promptæ³¨å…¥è¿‡å¤šå™ªéŸ³ (Lost in the Middle)

### ğŸ“Š é—®é¢˜è¯Šæ–­

**ç°æœ‰Promptç»“æ„ï¼š**

```python
prompt = f"""
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„åŠ å¯†è´§å¸äº¤æ˜“AIã€‚

# å¸‚åœºæ•°æ®
- ä»·æ ¼: {price}
- RSI: {rsi}
- MACD: {macd}
- å‡çº¿: {ma}
- æ”¯æ’‘é˜»åŠ›: {sr}
- æˆäº¤é‡: {volume}
- å†å²å›æµ‹: {backtest_stats}
- è´¦æˆ·çŠ¶æ€: {account_info}
... (å…±2000+ tokens)

è¯·åˆ†æå¹¶ç»™å‡ºäº¤æ˜“å†³ç­–ï¼ˆJSONæ ¼å¼ï¼‰
"""
```

**é—®é¢˜ï¼š**

1. **Lost in the Middleç°è±¡**
   - LLMå¯¹promptå¼€å¤´å’Œç»“å°¾çš„å…³æ³¨åº¦é«˜
   - ä¸­é—´çš„ä¿¡æ¯å®¹æ˜“è¢«å¿½ç•¥
   - å¤§é‡æŒ‡æ ‡å †ç Œå¯¼è‡´å…³é”®ä¿¡æ¯æ·¹æ²¡

2. **å¤„ç†å»¶è¿Ÿ**
   - Promptè¶Šé•¿ï¼ŒLLMå¤„ç†è¶Šæ…¢
   - DeepSeek/Qwenå¯¹é•¿promptçš„å¤„ç†èƒ½åŠ›æœ‰é™

3. **å†³ç­–è´¨é‡**
   - è¿‡å¤šå™ªéŸ³å¯èƒ½å¯¼è‡´è¯¯åˆ¤
   - AIå¯èƒ½è¿‡æ‹ŸåˆæŸäº›æ— å…³æŒ‡æ ‡

---

### ğŸ’° ä»·å€¼è¯„ä¼°

**ä¼˜åŠ¿ï¼š** â­â­â­â­â­

1. **æå‡AIå†³ç­–è´¨é‡**
   - å‡å°‘å™ªéŸ³å¹²æ‰°
   - å…³æ³¨æ ¸å¿ƒæŒ‡æ ‡
   - æ›´æ¸…æ™°çš„é€»è¾‘é“¾

2. **é™ä½å»¶è¿Ÿ**
   - æ›´çŸ­çš„prompt
   - æ›´å¿«çš„å¤„ç†é€Ÿåº¦
   - é™ä½Tokenæˆæœ¬

3. **å¯è§£é‡Šæ€§**
   - Chain of Thoughtæä¾›æ¨ç†è¿‡ç¨‹
   - æ›´å®¹æ˜“ç†è§£AIä¸ºä»€ä¹ˆè¿™æ ·å†³ç­–

**åŠ£åŠ¿ï¼š** âš ï¸âš ï¸

1. **å¢åŠ APIè°ƒç”¨æ¬¡æ•°**
   - å¤šæ­¥éª¤éœ€è¦å¤šæ¬¡è°ƒç”¨
   - æˆæœ¬å¯èƒ½å¢åŠ 

2. **å®ç°å¤æ‚åº¦**
   - éœ€è¦è®¾è®¡æ¨ç†é“¾
   - é”™è¯¯ä¼ æ’­é—®é¢˜

---

### ğŸ”§ å®ç°æ–¹æ¡ˆ

**æ–¹æ¡ˆAï¼šChain of Thoughtï¼ˆæ¨èï¼‰**

```python
class ChainOfThoughtAIAnalyzer:
    """
    ğŸ†• V8.9: é“¾å¼æ€è€ƒAIåˆ†æå™¨
    
    æ ¸å¿ƒæ€æƒ³ï¼š
    1. åˆ†æ­¥éª¤åˆ†æï¼Œæ¯æ­¥åªå…³æ³¨ç›¸å…³æŒ‡æ ‡
    2. å‰ä¸€æ­¥çš„ç»“è®ºä½œä¸ºåä¸€æ­¥çš„è¾“å…¥
    3. æœ€åç»¼åˆæ‰€æœ‰æ­¥éª¤åšå‡ºå†³ç­–
    """
    
    def __init__(self, client, model_name):
        self.client = client
        self.model_name = model_name
    
    def analyze_market(self, symbol: str, market_data: dict, account_info: dict) -> dict:
        """
        é“¾å¼æ€è€ƒåˆ†æå¸‚åœº
        
        æ­¥éª¤ï¼š
        1. è¶‹åŠ¿åˆ†æï¼ˆåªç”¨è¶‹åŠ¿ç›¸å…³æŒ‡æ ‡ï¼‰
        2. åŠ¨é‡åˆ†æï¼ˆåªç”¨åŠ¨é‡æŒ‡æ ‡ï¼‰
        3. é£é™©è¯„ä¼°ï¼ˆåªç”¨è´¦æˆ·å’Œé£æ§ä¿¡æ¯ï¼‰
        4. ç»¼åˆå†³ç­–ï¼ˆç»“åˆå‰3æ­¥ç»“è®ºï¼‰
        """
        
        # Step 1: è¶‹åŠ¿åˆ†æ
        trend_analysis = self._analyze_trend(symbol, market_data)
        print(f"[CoT] Step 1 - è¶‹åŠ¿: {trend_analysis['conclusion']}")
        
        # Step 2: åŠ¨é‡åˆ†æ
        momentum_analysis = self._analyze_momentum(symbol, market_data, trend_analysis)
        print(f"[CoT] Step 2 - åŠ¨é‡: {momentum_analysis['conclusion']}")
        
        # Step 3: é£é™©è¯„ä¼°
        risk_assessment = self._assess_risk(symbol, account_info, trend_analysis, momentum_analysis)
        print(f"[CoT] Step 3 - é£é™©: {risk_assessment['conclusion']}")
        
        # Step 4: ç»¼åˆå†³ç­–
        final_decision = self._make_final_decision(
            symbol, trend_analysis, momentum_analysis, risk_assessment, market_data
        )
        print(f"[CoT] Step 4 - å†³ç­–: {final_decision['action']}")
        
        return final_decision
    
    def _analyze_trend(self, symbol: str, market_data: dict) -> dict:
        """
        Step 1: è¶‹åŠ¿åˆ†æ
        
        åªå…³æ³¨ï¼š
        - å¤šå‘¨æœŸè¶‹åŠ¿ï¼ˆ4H, 1H, 15mï¼‰
        - å‡çº¿ç³»ç»Ÿ
        - ä»·æ ¼ç»“æ„
        """
        prompt = f"""You are a trend analysis expert.

# Symbol: {symbol}

# Trend Data (ONLY)
- 4H Trend: {market_data.get('trend_4h', 'N/A')}
- 1H Trend: {market_data.get('trend_1h', 'N/A')}
- 15m Trend: {market_data.get('trend_15m', 'N/A')}
- MA Alignment: {market_data.get('ma_alignment', 'N/A')}
- Price Structure: {market_data.get('price_structure', 'N/A')}

# Your Task
Analyze the trend and output JSON:
{{
  "trend_direction": "bullish"/"bearish"/"neutral",
  "trend_strength": 0-100,
  "trend_age": "new"/"mature"/"exhausted",
  "conclusion": "Brief summary (1 sentence)",
  "confidence": 0-100
}}

Output ONLY valid JSON, no markdown.
"""
        
        response = self.client.chat.completions.create(
            model=self.model_name,
            messages=[
                {"role": "system", "content": "You are a professional trend analyst. Output valid JSON only."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=300
        )
        
        content = response.choices[0].message.content.strip()
        if '```json' in content:
            content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            content = content.split('```')[1].split('```')[0].strip()
        
        return json.loads(content)
    
    def _analyze_momentum(self, symbol: str, market_data: dict, trend_analysis: dict) -> dict:
        """
        Step 2: åŠ¨é‡åˆ†æ
        
        åªå…³æ³¨ï¼š
        - RSI
        - MACD
        - æˆäº¤é‡
        - åŠ¨é‡æŒ‡æ ‡
        
        è€ƒè™‘å‰ä¸€æ­¥çš„è¶‹åŠ¿ç»“è®º
        """
        prompt = f"""You are a momentum analysis expert.

# Symbol: {symbol}

# Previous Step: Trend Analysis
{json.dumps(trend_analysis, indent=2)}

# Momentum Data (ONLY)
- RSI: {market_data.get('rsi', 'N/A')}
- MACD: {market_data.get('macd', 'N/A')}
- Volume: {market_data.get('volume', 'N/A')}
- Volume Surge: {market_data.get('volume_surge', 'N/A')}

# Your Task
Given the trend is {trend_analysis['trend_direction']}, analyze momentum:
{{
  "momentum_direction": "bullish"/"bearish"/"neutral",
  "momentum_strength": 0-100,
  "divergence": "none"/"bullish"/"bearish",
  "volume_confirmation": true/false,
  "conclusion": "Brief summary (1 sentence)",
  "confidence": 0-100
}}

Output ONLY valid JSON, no markdown.
"""
        
        response = self.client.chat.completions.create(
            model=self.model_name,
            messages=[
                {"role": "system", "content": "You are a professional momentum analyst. Output valid JSON only."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=300
        )
        
        content = response.choices[0].message.content.strip()
        if '```json' in content:
            content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            content = content.split('```')[1].split('```')[0].strip()
        
        return json.loads(content)
    
    def _assess_risk(self, symbol: str, account_info: dict, 
                     trend_analysis: dict, momentum_analysis: dict) -> dict:
        """
        Step 3: é£é™©è¯„ä¼°
        
        åªå…³æ³¨ï¼š
        - è´¦æˆ·ä½™é¢
        - å½“å‰æŒä»“
        - é£é™©æ•å£
        - ç›ˆäºæ¯”
        """
        prompt = f"""You are a risk management expert.

# Symbol: {symbol}

# Previous Steps
- Trend: {trend_analysis['conclusion']}
- Momentum: {momentum_analysis['conclusion']}

# Account & Risk Data (ONLY)
- Balance: {account_info.get('balance', 0)}
- Current Positions: {account_info.get('positions_count', 0)}
- Total Exposure: {account_info.get('total_exposure', 0)}
- Available Margin: {account_info.get('available_margin', 0)}

# Your Task
Assess if we should take risk now:
{{
  "risk_level": "low"/"medium"/"high"/"extreme",
  "max_leverage": 1-10,
  "position_size_pct": 0-100,
  "conclusion": "Brief assessment (1 sentence)",
  "confidence": 0-100
}}

Output ONLY valid JSON, no markdown.
"""
        
        response = self.client.chat.completions.create(
            model=self.model_name,
            messages=[
                {"role": "system", "content": "You are a professional risk manager. Output valid JSON only."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=300
        )
        
        content = response.choices[0].message.content.strip()
        if '```json' in content:
            content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            content = content.split('```')[1].split('```')[0].strip()
        
        return json.loads(content)
    
    def _make_final_decision(self, symbol: str, trend_analysis: dict, 
                            momentum_analysis: dict, risk_assessment: dict,
                            market_data: dict) -> dict:
        """
        Step 4: ç»¼åˆå†³ç­–
        
        åŸºäºå‰3æ­¥çš„ç»“è®ºåšå‡ºæœ€ç»ˆå†³ç­–
        """
        prompt = f"""You are a professional trader making final decision.

# Symbol: {symbol}
# Current Price: {market_data.get('price', 0)}

# Analysis Summary
1. Trend: {trend_analysis['conclusion']} (Confidence: {trend_analysis['confidence']}%)
2. Momentum: {momentum_analysis['conclusion']} (Confidence: {momentum_analysis['confidence']}%)
3. Risk: {risk_assessment['conclusion']} (Max Leverage: {risk_assessment['max_leverage']}x)

# Your Task
Based on the 3-step analysis above, make final trading decision:
{{
  "action": "OPEN_LONG"/"OPEN_SHORT"/"CLOSE"/"HOLD",
  "confidence": 0-100,
  "reason": "Brief reason referring to the 3 steps (max 200 chars)",
  "leverage": 1-{risk_assessment['max_leverage']},
  "signal_strength": 0-100,
  "signal_type": "scalping"/"swing",
  "strategy_type": "trend_following"/"mean_reversion"/"breakout"
}}

Output ONLY valid JSON, no markdown.
"""
        
        response = self.client.chat.completions.create(
            model=self.model_name,
            messages=[
                {"role": "system", "content": "You are a professional trader. Output valid JSON only."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=400
        )
        
        content = response.choices[0].message.content.strip()
        if '```json' in content:
            content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            content = content.split('```')[1].split('```')[0].strip()
        
        decision = json.loads(content)
        
        # æ·»åŠ è¯¦ç»†çš„reasoning chain
        decision['reasoning_chain'] = {
            'trend': trend_analysis,
            'momentum': momentum_analysis,
            'risk': risk_assessment
        }
        
        return decision
```

**æ–¹æ¡ˆBï¼šLLMä½œä¸ºå®è§‚åˆ†æå¸ˆï¼ˆæ›´æ¿€è¿›çš„æ–¹æ¡ˆï¼‰**

```python
# LLMåªè´Ÿè´£å®è§‚åˆ¤æ–­
llm_macro_view = ask_llm_macro_view(market_context)  # "çœ‹å¤š"/"çœ‹ç©º"/"è§‚æœ›"

# å…·ä½“å¼€å¹³ä»“ç”±ç¡¬ä»£ç æ‰§è¡Œ
if llm_macro_view == "çœ‹å¤š":
    # ç¡¬ä»£ç ï¼šæ£€æŸ¥çªç ´ä¿¡å·
    if price > resistance and volume > avg_volume * 1.5:
        execute_trade("OPEN_LONG", ...)
```

---

### ğŸ“ˆ å®ç°æˆæœ¬è¯„ä¼°

| ç»´åº¦ | CoT | LLMå®è§‚åˆ†æå¸ˆ | è¯´æ˜ |
|------|-----|--------------|------|
| **ä»£ç ä¿®æ”¹é‡** | â­â­â­â­ (å¤§) | â­â­â­ (ä¸­) | CoTéœ€è¦é‡æ„æ•´ä¸ªAIè°ƒç”¨ |
| **æµ‹è¯•éš¾åº¦** | â­â­â­ (ä¸­) | â­â­ (ä½) | CoTéœ€è¦æµ‹è¯•æ¯ä¸ªæ­¥éª¤ |
| **APIæˆæœ¬** | â­â­â­â­ (é«˜) | â­â­ (ä½) | CoTéœ€è¦4æ¬¡è°ƒç”¨ vs 1æ¬¡ |
| **å†³ç­–å»¶è¿Ÿ** | â­â­â­â­ (æ…¢) | â­â­ (å¿«) | CoTä¸²è¡Œè°ƒç”¨æ›´æ…¢ |
| **æ½œåœ¨é£é™©** | â­â­â­ (ä¸­) | â­â­ (ä½) | CoTæœ‰é”™è¯¯ä¼ æ’­é£é™© |
| **å·¥ç¨‹é‡ä¼°ç®—** | **7-10å¤©** | **3-5å¤©** | - |

---

### ğŸ’¡ å»ºè®®

**ä¼˜å…ˆçº§ï¼šâ­â­â­â˜†â˜† (P2 - ä¸­)**

**ç†ç”±ï¼š**
- âœ… ç†è®ºä»·å€¼é«˜ï¼ˆæå‡AIå†³ç­–è´¨é‡ï¼‰
- âš ï¸ APIæˆæœ¬å¢åŠ 4å€ï¼ˆCoTï¼‰
- âš ï¸ å»¶è¿Ÿå¢åŠ ï¼ˆä¸²è¡Œè°ƒç”¨ï¼‰
- ğŸ’¡ å½“å‰AIå†³ç­–è´¨é‡å¯æ¥å—

**å®æ–½å»ºè®®ï¼š**

**Short-termï¼ˆç«‹å³å¯åšï¼‰ï¼š**
1. **ç²¾ç®€ç°æœ‰Prompt**
   - åˆ é™¤ä½ç›¸å…³æ€§æŒ‡æ ‡
   - åªä¿ç•™æ ¸å¿ƒ10ä¸ªæŒ‡æ ‡
   - é¢„è®¡tokenå‡å°‘50%

2. **ç»“æ„åŒ–Prompt**
   ```
   # æ ¸å¿ƒæŒ‡æ ‡ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
   - è¶‹åŠ¿
   - åŠ¨é‡
   - æ”¯æ’‘é˜»åŠ›
   
   # æ¬¡è¦æŒ‡æ ‡
   - æˆäº¤é‡
   - RSI
   
   # å‚è€ƒä¿¡æ¯
   - è´¦æˆ·çŠ¶æ€
   ```

**Long-termï¼ˆå¯é€‰ï¼‰ï¼š**
3. **Chain of Thought**
   - åœ¨ç²¾ç®€ç‰ˆæœ¬ä¸å¤Ÿå¥½æ—¶å†è€ƒè™‘
   - æˆ–è€…åªåœ¨å…³é”®å†³ç­–æ—¶ä½¿ç”¨CoT
   
4. **æ··åˆæ¨¡å¼**
   - 15mè¶…çŸ­çº¿ï¼šç¡¬ä»£ç æ‰§è¡Œï¼ˆé€Ÿåº¦ä¼˜å…ˆï¼‰
   - 4Hæ³¢æ®µï¼šAIåˆ†æï¼ˆè´¨é‡ä¼˜å…ˆï¼‰

---

## å››ã€ç»¼åˆè¯„ä¼°ä¸ä¼˜å…ˆçº§

### ğŸ“Š å¯¹æ¯”çŸ©é˜µ

| ä¼˜åŒ–é¡¹ | ä»·å€¼ | æˆæœ¬ | é£é™© | å·¥ç¨‹é‡ | ROI | ä¼˜å…ˆçº§ |
|--------|------|------|------|--------|-----|--------|
| **è‡ªé€‚åº”ä¿¡å·éªŒè¯** | â­â­â­â­â­ | â­â­â­ | â­â­â­ | 3-5å¤© | **æé«˜** | **P1** |
| **Chase Logic** | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | 7-10å¤© | ä½ | **P3** |
| **Promptä¼˜åŒ–** | â­â­â­â­ | â­â­ | â­ | 1-2å¤© | **é«˜** | **P1** |
| **Chain of Thought** | â­â­â­â­ | â­â­â­â­ | â­â­â­ | 7-10å¤© | ä¸­ | **P2** |

---

### ğŸ¯ å®æ–½è·¯çº¿å›¾

**Phase 1ï¼ˆç«‹å³å®æ–½ï¼Œ3-5å¤©ï¼‰**

1. âœ… **è‡ªé€‚åº”ä¿¡å·éªŒè¯** (3-5å¤©)
   - è§£å†³çªç ´ç­–ç•¥çš„å¹¸å­˜è€…åå·®
   - åŒºåˆ†Trend Following / Mean Reversion / Breakout
   - åŠ¨æ€åç¦»é˜ˆå€¼
   - **é¢„æœŸæ”¶ç›Š: +20-30%æœºä¼šæ•è·**

2. âœ… **Promptç²¾ç®€** (1-2å¤©)
   - åˆ é™¤ä½ç›¸å…³æ€§æŒ‡æ ‡
   - ç»“æ„åŒ–Prompt
   - å‡å°‘50% token
   - **é¢„æœŸæ”¶ç›Š: -30%å»¶è¿Ÿ, -50%æˆæœ¬**

**Phase 2ï¼ˆä¸­æœŸä¼˜åŒ–ï¼Œå¯é€‰ï¼‰**

3. ğŸ’¡ **Chain of Thought** (7-10å¤©)
   - æå‡AIå†³ç­–è´¨é‡
   - åˆ†æ­¥æ¨ç†
   - åªåœ¨å…³é”®å†³ç­–æ—¶ä½¿ç”¨
   - **é¢„æœŸæ”¶ç›Š: +10-15%å†³ç­–å‡†ç¡®ç‡**

**Phase 3ï¼ˆé•¿æœŸè€ƒè™‘ï¼‰**

4. ğŸ’¡ **Chase Logic** (7-10å¤©)
   - å®ç°å¤æ‚åº¦æé«˜
   - é£é™©æå¤§
   - åªåœ¨è¸ç©ºç‡>20%æ—¶è€ƒè™‘
   - **é¢„æœŸæ”¶ç›Š: +5-10%æˆäº¤ä¼˜åŒ–**

---

## äº”ã€æ€»ç»“

### âœ… ç«‹å³å®æ–½ï¼ˆP1 - é«˜ä¼˜å…ˆçº§ï¼‰

**1. è‡ªé€‚åº”ä¿¡å·éªŒè¯**
- ğŸ’° ä»·å€¼ï¼šâ­â­â­â­â­
- ğŸ”§ æˆæœ¬ï¼šâ­â­â­
- ğŸ“Š ROIï¼šæé«˜
- â±ï¸ å·¥æœŸï¼š3-5å¤©

**2. Promptç²¾ç®€**
- ğŸ’° ä»·å€¼ï¼šâ­â­â­â­
- ğŸ”§ æˆæœ¬ï¼šâ­â­
- ğŸ“Š ROIï¼šé«˜
- â±ï¸ å·¥æœŸï¼š1-2å¤©

**åˆè®¡ï¼š4-7å¤©ï¼Œè§£å†³2ä¸ªå…³é”®ç—›ç‚¹**

---

### âš ï¸ æš‚ç¼“å®æ–½

**3. Chase Logic**
- ç†ç”±ï¼šå®ç°æå…¶å¤æ‚ï¼Œé£é™©æé«˜
- å½“å‰V8.7çš„aggressive_limitå·²å¤Ÿç”¨
- å¯ä»¥å…ˆç›‘æ§è¸ç©ºç‡ï¼Œå†å†³å®šæ˜¯å¦å®æ–½

**4. Chain of Thought (Full Version)**
- ç†ç”±ï¼šAPIæˆæœ¬å¢åŠ 4å€ï¼Œå»¶è¿Ÿå¢åŠ 
- å½“å‰AIå†³ç­–è´¨é‡å¯æ¥å—
- å¯ä»¥ä½œä¸ºé•¿æœŸä¼˜åŒ–æ–¹å‘

---

**ç”Ÿæˆæ—¥æœŸ**: 2025-11-22  
**ç‰ˆæœ¬**: V8.9ææ¡ˆ  
**çŠ¶æ€**: å¾…ç”¨æˆ·ç¡®è®¤

