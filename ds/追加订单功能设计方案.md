# 追加订单（加仓）功能设计方案

## 当前问题

**现象**：
当AI建议对已有持仓的币种再次开仓时，系统拒绝并发送bark通知：
```
❌ 该币种已有short仓位（0.00U），不允许同方向开第二单
建议：追加到现有订单或等待平仓后再开
```

**原因**：
- `check_single_direction_per_coin()` 函数禁止同币种同方向开第二单
- 注释中提到"可以追加到现有订单"，但实际未实现

## 设计目标

实现一个**智能加仓系统**，允许在满足条件时追加仓位，同时保持风险可控。

## 方案对比

### 方案1：完全禁止（当前）

**优点**：
- 简单、风险低
- 避免仓位失控
- CSV记录清晰

**缺点**：
- 错过优质加仓机会
- 无法利用金字塔加仓策略
- 分批平仓后无法重新开仓

### 方案2：自动合并加仓（推荐）⭐

**核心思路**：
- 不开新订单，而是"合并"到现有持仓
- 更新平均开仓价、总仓位、保证金
- 重新计算止盈止损
- 在CSV中记录加仓历史

**优点**：
- 支持金字塔加仓策略
- 仓位管理统一，不会混乱
- CSV记录仍然清晰（一行记录）
- 风险可控（受总仓位限制）

**缺点**：
- 实现复杂度中等
- 平均价计算需要准确

### 方案3：允许多单并行

**优点**：
- 可以分别管理多个入场点

**缺点**：
- CSV记录复杂
- 止盈止损管理混乱
- 平仓时难以决策
- 风险难以控制

**结论**：推荐**方案2（自动合并加仓）**

## 详细设计（方案2）

### 1. 触发条件

加仓需要满足以下**所有条件**：

#### 1.1 基础条件
- ✅ 已有同币种同方向的持仓
- ✅ AI给出新的开仓建议（同方向）

#### 1.2 风控条件
- ✅ 加仓后总仓位 ≤ 可用资金的50%
- ✅ 加仓后单币种仓位 ≤ 总资金的30%
- ✅ 现有持仓未处于浮亏状态（或浮亏<5%）
- ✅ 信号质量 ≥ 现有持仓的开仓信号质量

#### 1.3 技术条件（满足任一即可）
- ✅ 价格更优：空单加仓价更高，多单加仓价更低（金字塔加仓）
- ✅ 趋势增强：新信号的consensus_score > 现有开仓时的score
- ✅ 分批平仓后补仓：已分批平仓50%，价格回到有利位置

### 2. 加仓逻辑

#### 2.1 仓位合并

```python
def add_to_position(symbol, side, new_amount, new_price, new_leverage, current_position):
    """
    合并加仓到现有持仓
    
    Args:
        symbol: 交易对
        side: 方向
        new_amount: 新增数量
        new_price: 新增价格
        new_leverage: 新增杠杆
        current_position: 当前持仓信息
    
    Returns:
        加仓是否成功
    """
    # 1. 计算原持仓成本
    old_amount = current_position['size']
    old_price = current_position['entry_price']
    old_cost = old_amount * old_price
    
    # 2. 计算新增成本
    new_cost = new_amount * new_price
    
    # 3. 计算合并后的平均价
    total_amount = old_amount + new_amount
    avg_price = (old_cost + new_cost) / total_amount
    
    # 4. 执行开仓（市价单）
    order = exchange.create_market_order(
        symbol,
        'buy' if side == 'long' else 'sell',
        new_amount,
        params={'tag': 'f1ee03b510d5SUDE'}
    )
    
    # 5. 更新CSV记录（追加加仓历史到开仓理由）
    update_position_after_adding(
        symbol, side, 
        new_avg_price=avg_price,
        new_total_amount=total_amount,
        new_amount=new_amount,
        new_price=new_price,
        add_reason=ai_signal.get('reason', ''),  # AI给出的开仓理由
        signal_score=ai_signal.get('signal_quality', 0),
        price_improvement_pct=price_improvement  # 价格改善百分比
    )
    
    # 6. 重新计算并设置止盈止损
    recalculate_tpsl(symbol, side, avg_price, total_amount)
    
    return True
```

#### 2.3 加仓历史记录函数

```python
def update_position_after_adding(symbol, side, new_avg_price, new_total_amount, 
                                  new_amount, new_price, add_reason, signal_score, 
                                  price_improvement_pct):
    """
    更新CSV记录，追加加仓历史
    
    格式：原始理由 | [加仓N] 时间 +数量@价格 理由:xxx
    """
    import fcntl
    import shutil
    
    coin_name = symbol.split('/')[0]
    side_cn = "多" if side == "long" else "空"
    
    max_retries = 3
    for attempt in range(max_retries):
        lock_file = None
        try:
            # 1. 创建文件锁
            lock_path = TRADES_FILE.parent / f"{TRADES_FILE.name}.lock"
            lock_file = open(lock_path, "w")
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            
            # 2. 创建备份
            backup_path = TRADES_FILE.parent / f"{TRADES_FILE.name}.backup"
            shutil.copy2(TRADES_FILE, backup_path)
            
            # 3. 读取现有数据
            df = pd.read_csv(TRADES_FILE, encoding="utf-8")
            df.columns = df.columns.str.strip().str.replace("\ufeff", "")
            
            # 4. 找到该币种、该方向、未平仓的记录
            mask = (
                (df["币种"] == coin_name)
                & (df["方向"] == side_cn)
                & (df["平仓时间"].isna())
            )
            matching_rows = df[mask]
            
            if matching_rows.empty:
                print(f"⚠️ 未找到 {coin_name} {side_cn} 的未平仓记录")
                fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)
                lock_file.close()
                return
            
            # 5. 更新记录
            last_idx = matching_rows.index[-1]
            original_reason = df.at[last_idx, "开仓理由"]
            
            # 计算是第几次加仓
            add_count = original_reason.count("[加仓") + 1
            
            # 构建加仓记录
            current_time = datetime.now().strftime("%H:%M")
            add_entry = (
                f" | [加仓{add_count}] {current_time} "
                f"+{new_amount:.3f}@{new_price:.2f} "
                f"理由:{add_reason}+价格优{price_improvement_pct:.1f}%+信号分{signal_score}"
            )
            
            # 更新字段
            df.at[last_idx, "开仓价"] = new_avg_price
            df.at[last_idx, "数量"] = new_total_amount  # 需要添加这个字段到CSV
            df.at[last_idx, "开仓理由"] = original_reason + add_entry
            
            # 6. 保存
            temp_file = TRADES_FILE.parent / f"{TRADES_FILE.name}.tmp"
            df.to_csv(temp_file, index=False, encoding="utf-8")
            temp_file.replace(TRADES_FILE)
            
            print(f"  📝 已记录加仓{add_count}: +{new_amount:.3f}@{new_price:.2f}")
            
            # 7. 释放锁
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)
            lock_file.close()
            break
            
        except Exception as e:
            print(f"⚠️ 更新加仓记录失败 (尝试 {attempt + 1}/{max_retries}): {e}")
            if lock_file:
                try:
                    fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)
                    lock_file.close()
                except:
                    pass
            
            if attempt == max_retries - 1:
                print(f"❌ 加仓记录更新失败")
            else:
                import time
                time.sleep(0.5)
                continue
```

#### 2.2 CSV记录更新（完整历史追踪）

**记录格式设计**：

开仓理由字段使用分隔符 `|` 来区分原始开仓和每次加仓：

```
[原始开仓理由] | [加仓1] 时间 +数量@价格 理由:xxx | [加仓2] 时间 +数量@价格 理由:xxx
```

**示例：**

**初始开仓**：
```csv
币种,方向,开仓时间,开仓价,数量,杠杆率,止损,止盈,盈亏比,开仓理由
BNB,空,2025-11-16 12:45:00,933,0.01,5,945,900,3.3,"Simple Pullback (Retrace 0.6%, Recover 65%) 信号分:95"
```

**第一次加仓后**：
```csv
币种,方向,开仓时间,开仓价,数量,杠杆率,止损,止盈,盈亏比,开仓理由
BNB,空,2025-11-16 12:45:00,935.5,0.02,5,945,895,3.0,"Simple Pullback (Retrace 0.6%, Recover 65%) 信号分:95 | [加仓1] 13:20 +0.01@938 理由:金字塔加仓+价格更优2.1%+信号分97"
```

**第二次加仓后**：
```csv
币种,方向,开仓时间,开仓价,数量,杠杆率,止损,止盈,盈亏比,开仓理由
BNB,空,2025-11-16 12:45:00,937,0.03,5,946,892,2.8,"Simple Pullback (Retrace 0.6%, Recover 65%) 信号分:95 | [加仓1] 13:20 +0.01@938 理由:金字塔加仓+价格更优2.1%+信号分97 | [加仓2] 14:05 +0.01@940 理由:趋势增强+突破阻力+信号分99"
```

**关键字段更新**：
- **开仓价**：更新为加权平均价
  - 第1次加仓：(933×0.01 + 938×0.01) / 0.02 = 935.5
  - 第2次加仓：(935.5×0.02 + 940×0.01) / 0.03 = 937
- **数量**：累加（0.01 → 0.02 → 0.03）
- **止损/止盈**：基于新平均价重新计算
- **盈亏比**：基于新止盈止损计算
- **开仓理由**：保留完整加仓历史，用 `|` 分隔

**格式规范**：
```
[加仓N] 时间 +数量@价格 理由:具体原因

示例：
[加仓1] 13:20 +0.01@938 理由:金字塔加仓+价格更优2.1%+信号分97
```

**字段说明**：
- `[加仓N]`：第几次加仓，便于识别
- `时间`：HH:MM格式（同一天，省略日期）
- `+数量@价格`：新增数量和加仓价格
- `理由:`：详细的加仓判断依据，包括：
  - 加仓类型（金字塔/趋势增强/分批后补仓）
  - 价格优势百分比
  - 新信号评分
  - 技术形态（如有）

#### 2.4 AI回测时的解析方法

**解析函数**：

```python
def parse_position_history(reason_text):
    """
    解析开仓理由字段，提取完整的开仓和加仓历史
    
    Args:
        reason_text: 开仓理由字段的完整文本
    
    Returns:
        {
            'original_reason': str,  # 原始开仓理由
            'add_positions': [       # 加仓历史列表
                {
                    'add_number': 1,
                    'time': '13:20',
                    'amount': 0.01,
                    'price': 938.0,
                    'reason': '金字塔加仓+价格更优2.1%+信号分97'
                },
                ...
            ]
        }
    """
    import re
    
    # 1. 按 | 分割
    parts = reason_text.split('|')
    
    # 2. 提取原始开仓理由
    original_reason = parts[0].strip()
    
    # 3. 解析加仓历史
    add_positions = []
    pattern = r'\[加仓(\d+)\]\s+(\d{2}:\d{2})\s+\+([\d.]+)@([\d.]+)\s+理由:(.*)'
    
    for part in parts[1:]:
        match = re.match(pattern, part.strip())
        if match:
            add_positions.append({
                'add_number': int(match.group(1)),
                'time': match.group(2),
                'amount': float(match.group(3)),
                'price': float(match.group(4)),
                'reason': match.group(5).strip()
            })
    
    return {
        'original_reason': original_reason,
        'add_positions': add_positions
    }

# 使用示例
reason_text = "Simple Pullback 信号分:95 | [加仓1] 13:20 +0.01@938 理由:金字塔加仓+价格更优2.1%+信号分97"
parsed = parse_position_history(reason_text)

# 结果：
# {
#     'original_reason': 'Simple Pullback 信号分:95',
#     'add_positions': [
#         {
#             'add_number': 1,
#             'time': '13:20',
#             'amount': 0.01,
#             'price': 938.0,
#             'reason': '金字塔加仓+价格更优2.1%+信号分97'
#         }
#     ]
# }
```

**AI学习分析**：

回测优化器可以分析：
1. **加仓效果**：加仓后的盈亏表现是否优于不加仓
2. **加仓时机**：什么条件下加仓成功率更高
3. **价格改善**：价格改善多少百分比时加仓效果最好
4. **信号质量**：加仓信号分数与最终收益的相关性
5. **加仓次数**：加仓1次 vs 2次的胜率差异

```python
# 回测分析示例
def analyze_add_position_performance(trades_df):
    """
    分析加仓策略的表现
    """
    results = {
        'with_add': [],    # 有加仓的交易
        'without_add': []  # 无加仓的交易
    }
    
    for _, trade in trades_df.iterrows():
        reason = trade['开仓理由']
        pnl = trade['盈亏(U)']
        
        # 解析是否有加仓
        parsed = parse_position_history(reason)
        
        if parsed['add_positions']:
            # 有加仓
            results['with_add'].append({
                'pnl': pnl,
                'add_count': len(parsed['add_positions']),
                'price_improvements': [
                    # 从reason中提取价格改善百分比
                    extract_price_improvement(pos['reason'])
                    for pos in parsed['add_positions']
                ],
                'signal_scores': [
                    extract_signal_score(pos['reason'])
                    for pos in parsed['add_positions']
                ]
            })
        else:
            # 无加仓
            results['without_add'].append({'pnl': pnl})
    
    # 统计分析
    with_add_winrate = sum(1 for x in results['with_add'] if x['pnl'] > 0) / len(results['with_add'])
    without_add_winrate = sum(1 for x in results['without_add'] if x['pnl'] > 0) / len(results['without_add'])
    
    print(f"有加仓胜率: {with_add_winrate:.1%}")
    print(f"无加仓胜率: {without_add_winrate:.1%}")
    
    return results
```

### 3. 代码实现

#### 3.1 修改 `check_single_direction_per_coin`

```python
def check_single_direction_per_coin(symbol, operation, current_positions, ai_signal=None):
    """
    检查单币种单方向限制，支持智能加仓
    
    新增参数：
        ai_signal: AI信号信息（用于判断是否允许加仓）
    
    Returns:
        (allowed: bool, reason: str, should_add: bool)
        should_add=True表示应该加仓而非新开
    """
    # ...原有检查逻辑...
    
    if existing_side == new_side:
        # 检查是否满足加仓条件
        can_add, add_reason = check_add_position_conditions(
            symbol, existing_position, ai_signal
        )
        
        if can_add:
            return True, f"满足加仓条件：{add_reason}", True  # should_add=True
        else:
            return False, f"不满足加仓条件：{add_reason}", False
```

#### 3.2 新增加仓条件检查函数

```python
def check_add_position_conditions(symbol, existing_position, ai_signal):
    """
    检查是否满足加仓条件
    
    Returns:
        (can_add: bool, reason: str)
    """
    # 1. 检查现有持仓状态
    current_pnl_pct = existing_position.get('unrealized_pnl', 0) / existing_position.get('notional', 1)
    if current_pnl_pct < -0.05:  # 浮亏超过5%
        return False, f"现有持仓浮亏{current_pnl_pct*100:.1f}%，不允许加仓"
    
    # 2. 检查信号质量
    if ai_signal:
        new_score = ai_signal.get('signal_quality', 0)
        # 从position_contexts读取原始信号质量
        old_score = get_original_signal_score(symbol)
        if new_score < old_score * 0.9:  # 新信号质量低于原信号的90%
            return False, f"新信号质量{new_score}低于原信号{old_score}"
    
    # 3. 检查价格是否更优（金字塔加仓）
    entry_price = existing_position.get('entry_price', 0)
    current_price = ai_signal.get('entry_price', 0) if ai_signal else 0
    side = existing_position.get('side', '')
    
    if side == 'short' and current_price <= entry_price:
        return False, f"空单加仓需价格更高（当前{current_price}≤开仓价{entry_price}）"
    if side == 'long' and current_price >= entry_price:
        return False, f"多单加仓需价格更低（当前{current_price}≥开仓价{entry_price}）"
    
    # 4. 检查总仓位限制（加仓后不超过50%）
    new_position_value = ai_signal.get('position_size_usd', 0)
    total_after_add = existing_position.get('notional', 0) + new_position_value
    # 假设available_balance从全局获取
    if total_after_add > available_balance * 0.5:
        return False, f"加仓后总仓位{total_after_add}U超过50%限制"
    
    # 所有条件满足
    return True, f"价格更优+信号强+仓位可控"
```

#### 3.3 修改开仓执行函数

```python
# 在 _execute_single_open_action 中
direction_ok, direction_reason, should_add = check_single_direction_per_coin(
    symbol, operation, current_positions, ai_signal=action
)

if not direction_ok:
    # 拒绝开仓
    print(f"❌ {direction_reason}")
    send_bark_notification(...)
    return
elif should_add:
    # 执行加仓
    print(f"🔼 满足加仓条件：{direction_reason}")
    add_to_position(symbol, side, amount, entry_price, leverage, existing_position)
    send_bark_notification(
        f"[通义千问]{coin_name}加仓✅",
        f"{side}仓 加仓{amount:.3f}个 @{entry_price:.2f}\n"
        f"新平均价: {new_avg_price:.2f}\n"
        f"总仓位: {total_amount:.3f}个\n"
        f"{direction_reason}"
    )
    return
else:
    # 正常开仓
    print(f"✓ {direction_reason}")
    # ...原有开仓逻辑...
```

### 4. Bark通知设计

#### 4.1 加仓成功通知
```
[通义千问]BNB加仓✅
空仓 加仓0.010个 @928
新平均价: 930.50
总仓位: 0.020个 (9.3U)
理由: 价格更优+信号强(95分)
```

#### 4.2 加仓被拒通知
```
[通义千问]BNB加仓被拒❌
原因: 价格不优（928≤933）
建议: 等待更高价格或现有持仓平仓后再开
```

### 5. 风险控制

#### 5.1 加仓频率限制
- 同一币种1小时内最多加仓1次
- 记录在 `position_contexts.json` 中

#### 5.2 加仓次数限制
- 单个持仓最多加仓2次
- 防止无限加仓导致仓位失控

#### 5.3 紧急平仓
- 如果加仓后浮亏超过10%，立即全部平仓

### 6. 测试场景

#### 场景1：金字塔加仓（推荐）
```
1. BNB空单开仓 @933，仓位0.01
2. 价格上涨到 938，AI建议再次做空
3. 检查：价格更优✅ + 信号强✅ + 浮盈✅
4. 执行：加仓0.01 @938
5. 结果：平均价930.5，总仓位0.02
```

#### 场景2：分批平仓后补仓
```
1. BNB空单开仓 @933，仓位0.02
2. 达目标，分批平仓50%，剩余0.01
3. 价格反弹到 935，AI建议再次做空
4. 检查：价格更优✅ + 信号强✅
5. 执行：加仓0.01 @935
6. 结果：平均价934，总仓位0.02（恢复原仓位）
```

#### 场景3：被拒绝（价格不优）
```
1. BNB空单开仓 @933，仓位0.01
2. 价格下跌到 928，AI建议再次做空
3. 检查：价格不优❌（空单需价格更高）
4. 拒绝：发送bark通知
```

#### 场景4：被拒绝（信号质量低）
```
1. BNB空单开仓 @933，信号分95分
2. 价格上涨到 938，AI建议再次做空，信号分80分
3. 检查：信号质量低❌（80 < 95*0.9=85.5）
4. 拒绝：发送bark通知
```

## 实施计划

### Phase 1：基础加仓功能
- [ ] 修改 `check_single_direction_per_coin` 函数
- [ ] 实现 `check_add_position_conditions` 函数
- [ ] 实现 `add_to_position` 函数
- [ ] 修改开仓执行逻辑
- [ ] 测试基本加仓流程

### Phase 2：完善风控
- [ ] 添加加仓频率限制
- [ ] 添加加仓次数限制
- [ ] 实现紧急平仓机制
- [ ] 测试各种边界情况

### Phase 3：优化体验
- [ ] 优化Bark通知内容
- [ ] 在前端显示加仓历史
- [ ] 添加加仓统计分析
- [ ] 文档和部署指南

## 配置参数（可调）

```python
ADD_POSITION_CONFIG = {
    # 加仓条件
    'max_loss_pct': -0.05,           # 最大允许浮亏5%
    'min_signal_quality_ratio': 0.9,  # 新信号至少是原信号的90%
    'max_total_position_pct': 0.5,    # 加仓后总仓位不超过50%
    'max_single_coin_pct': 0.3,       # 单币种不超过30%
    
    # 加仓限制
    'max_add_count': 2,               # 最多加仓2次
    'min_add_interval_minutes': 60,   # 加仓间隔至少60分钟
    
    # 金字塔加仓
    'pyramid_min_price_improvement_pct': 0.005,  # 空单至少高0.5%，多单至少低0.5%
    
    # 紧急平仓
    'emergency_close_loss_pct': -0.10,  # 加仓后浮亏超过10%立即平仓
}
```

## 总结

**推荐方案**：自动合并加仓（方案2）

**核心优势**：
1. 支持金字塔加仓策略，把握优质加仓机会
2. 仓位统一管理，避免记录混乱
3. 严格风控条件，防止仓位失控
4. 实现复杂度适中，可维护性好

**下一步**：
1. 确认方案可行性
2. 实施Phase 1（基础功能）
3. 测试验证
4. 逐步完善风控和体验

---

**版本**：V1.0
**设计日期**：2025-11-16
**状态**：待实施

