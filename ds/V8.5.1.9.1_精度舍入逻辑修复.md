# V8.5.1.9.1 精度舍入逻辑修复

## 问题发现

部署V8.5.1.9后，仍然出现舍入异常：

```
计算数量: 0.366927 → 舍入后: 0.000000
舍入后名义价值: $0.00
最小要求: >$100.00
```

## 根本原因

**math.floor舍入逻辑过于激进**：

```python
# 旧代码（有问题）
amount_step = 10 ** (-amount_precision)
rounded_amount = math.floor(calculated_amount / amount_step) * amount_step
```

**问题分析**：
1. 如果`amount_precision`获取失败（为0或None）
2. `amount_step = 10 ** 0 = 1`
3. `math.floor(0.366927 / 1) = 0`
4. 正常数量被强制归零！

**为什么precision会失败**：
- ccxt库返回的market_info结构可能不一致
- 某些交易对的precision字段可能为None
- 默认值3不适用所有情况

## 修复方案

### 核心改进

**1. 改用round代替floor**
```python
# math.floor强制向下 → round四舍五入
rounded_amount = round(calculated_amount / amount_step) * amount_step
```

**2. 添加保护机制**
```python
# 确保舍入后不会损失超过90%
if rounded_amount <= 0 or rounded_amount < calculated_amount * 0.1:
    print(f"   ⚠️ 精度舍入异常，使用原始值")
    rounded_amount = calculated_amount
```

**3. 异常处理回退**
```python
try:
    # 尝试精度舍入
    ...
except Exception as e:
    print(f"   ⚠️ 精度计算失败: {e}，使用原始值")
    rounded_amount = calculated_amount
```

**4. 简化最小要求**
```python
# 统一使用5 USDT，不再动态判断
min_notional_required = 5
```

### 完整修复代码

```python
# 🔧 V8.5.1.9改进：安全的精度舍入
try:
    # 尝试使用精度信息
    if amount_precision and amount_precision > 0:
        amount_step = 10 ** (-amount_precision)
        rounded_amount = round(calculated_amount / amount_step) * amount_step
    else:
        # 精度信息无效，使用原始值
        rounded_amount = calculated_amount
    
    # 保护机制：确保舍入后不会变成0或负数
    if rounded_amount <= 0 or rounded_amount < calculated_amount * 0.1:
        print(f"   ⚠️ 精度舍入异常（{calculated_amount:.6f}→{rounded_amount:.6f}），使用原始值")
        rounded_amount = calculated_amount
except Exception as e:
    print(f"   ⚠️ 精度计算失败: {e}，使用原始值")
    rounded_amount = calculated_amount

# 计算舍入后的实际名义价值
actual_notional = rounded_amount * entry_price

# 简化逻辑：统一使用5 USDT作为最小要求
min_notional_required = 5
```

## 修复效果对比

### 修复前（floor + 无保护）

**场景1：precision失败**
```
precision: None 或 0
amount_step: 1
calculated: 0.366927
rounded: math.floor(0.366927/1)*1 = 0 ❌
结果: 开仓失败
```

**场景2：BTC小仓位**
```
precision: 3
calculated: 0.00125
rounded: math.floor(0.00125/0.001)*0.001 = 0.001 ✓
notional: 0.001 × $95000 = $95 < $100 ❌
结果: 需要AI调整
```

### 修复后（round + 保护）

**场景1：precision失败**
```
precision: None 或 0
检测到异常 → 使用原始值
rounded: 0.366927 ✓
notional: 0.366927 × $95.69 = $35.11 > $5 ✓
结果: 开仓成功
```

**场景2：LTC正常仓位**
```
precision: 3（假设正确）
calculated: 0.366927
rounded: round(0.366927/0.001)*0.001 = 0.367 ✓
notional: 0.367 × $95.69 = $35.10 > $5 ✓
结果: 开仓成功
```

**场景3：BTC小仓位**
```
precision: 3
calculated: 0.00125
rounded: round(0.00125/0.001)*0.001 = 0.001 ✓
notional: 0.001 × $95000 = $95 > $5 ✓
结果: 开仓成功（不再要求100）
```

## 关键改进

| 项目 | 旧逻辑 | 新逻辑 |
|------|--------|--------|
| 舍入方式 | math.floor（向下） | round（四舍五入） |
| 保护机制 | ❌ 无 | ✅ 检测异常值 |
| 异常处理 | ❌ 无 | ✅ 回退到原始值 |
| 最小要求 | 动态（5或100） | 固定5 USDT |
| precision失败 | 归零 ❌ | 使用原始值 ✓ |

## 修改文件

- ✅ `ds/deepseek_多币种智能版.py`（第17692-17723行）
- ✅ `ds/qwen_多币种智能版.py`（第17689-17720行）

## 部署说明

代码已在本地修改完成，需要在服务器执行：

```bash
cd ~/10-23-bot
git pull origin main
pkill -f deepseek_多币种智能版.py
cd ds
nohup python3 deepseek_多币种智能版.py > ~/deepseek.log 2>&1 &
```

## 预期日志

**成功场景**：
```
✓ 智能计算仓位: $11.70
✓ 使用AI建议杠杆: 3x
   💡 仓位自动调整: $11.70 → $1.20 (满足最小名义价值$5)
✓ 设置杠杆率: 3x
开空仓: $1.20 3x杠杆 (约0.367个)
✓ 开仓成功
```

**异常保护场景**：
```
   ⚠️ 精度舍入异常（0.366927→0.000000），使用原始值
计算数量: 0.366927 → 舍入后: 0.366927
舍入后名义价值: $35.11
最小要求: >$5.00 ✓
继续开仓...
```

## 版本信息

- **版本号**：V8.5.1.9.1 → V8.5.1.9.2（BTC特殊处理）
- **修复日期**：2025-11-16 → 2025-11-17
- **修复内容**：精度舍入逻辑保护机制 + BTC特殊最小值
- **依赖版本**：V8.5.1.9
- **向下兼容**：是

## V8.5.1.9.2 追加修复（2025-11-17）

**问题发现**：
```
BTC开仓: $18.95 5x杠杆 (约0.001个)
名义价值: $94.735 < $100 ❌
错误: Order's notional must be greater than 100
```

**根本原因**：
- V8.5.1.9.1统一使用5 USDT（错误！）
- BTC因价格高、精度粗，币安要求 > 100 USDT
- 其他币种确实只需要 5 USDT

**追加修复**：
```python
# 🔧 V8.5.1.9.2: 根据币种动态判断
coin_name = symbol.split('/')[0]
if coin_name == 'BTC':
    MIN_NOTIONAL = 100  # BTC特殊要求
else:
    MIN_NOTIONAL = 5    # 其他币种标准要求
```

**修改位置**：
1. V8.5.1.9前置检查（第17457-17464行）
2. V8.5.1.2精度检查（第17728-17733行）

**修复效果**：
| 币种 | 最小名义价值 | 仓位需求（5x杠杆）|
|------|-------------|------------------|
| BTC  | $100        | $24              |
| ETH  | $5          | $1.20            |
| SOL  | $5          | $1.20            |
| 其他 | $5          | $1.20            |

## 总结

**核心问题**：
- ❌ math.floor过于激进，小数量直接归零
- ❌ precision获取失败时无保护
- ❌ BTC和其他币种未区分最小值

**解决方案**：
- ✅ 改用round四舍五入
- ✅ 添加保护机制，检测异常值
- ✅ 异常时回退到原始值
- ✅ BTC使用100 USDT，其他币种5 USDT

**预期效果**：
- 📈 开仓成功率接近100%
- 🛡️ 异常情况有保护
- 💡 调试信息更清晰
- 🎯 BTC和其他币种分别处理
- 🚀 支持各种账户规模

