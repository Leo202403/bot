# 分批止盈与订单记录说明

## 📊 分批止盈机制

系统支持**分批止盈**，即同一个开仓可以分多次平仓。

### 示例场景

#### 开仓
```
时间: 2025-11-20 10:00:00
币种: BTC
方向: 多
数量: 0.01 BTC
开仓价: $92,000
```

#### 分批平仓
```
第1次止盈 (30%):
  时间: 2025-11-20 12:00:00
  数量: 0.003 BTC
  平仓价: $93,500
  盈亏: +4.5 USDT

第2次止盈 (30%):
  时间: 2025-11-20 14:00:00
  数量: 0.003 BTC
  平仓价: $94,200
  盈亏: +6.6 USDT

第3次止盈 (40%):
  时间: 2025-11-20 16:00:00
  数量: 0.004 BTC
  平仓价: $95,000
  盈亏: +12 USDT
```

### CSV记录

这种情况下，`trades_history.csv` 会有**3条记录**：

| 开仓时间 | 平仓时间 | 币种 | 方向 | 数量 | 开仓价格 | 平仓价格 | 盈亏(U) |
|---------|---------|------|------|------|----------|----------|---------|
| 2025-11-20 10:00:00 | 2025-11-20 12:00:00 | BTC | 多 | 0.003 | 92000 | 93500 | 4.5 |
| 2025-11-20 10:00:00 | 2025-11-20 14:00:00 | BTC | 多 | 0.003 | 92000 | 94200 | 6.6 |
| 2025-11-20 10:00:00 | 2025-11-20 16:00:00 | BTC | 多 | 0.004 | 92000 | 95000 | 12.0 |

**关键特征**：
- ✅ 开仓时间相同
- ✅ 币种、方向、开仓价格相同
- ❌ 平仓时间**不同**
- ❌ 平仓价格可能**不同**
- ❌ 数量**不同**（部分数量）
- ❌ 盈亏**不同**

## 🔍 重复记录判断逻辑

### 旧逻辑（错误）

```python
# ❌ 错误：只看开仓信息
key = f"{币种}_{方向}_{开仓时间}"

# 问题：会误判分批止盈为重复
# 上面3条记录都会被认为是重复的
```

### 新逻辑（正确）

```python
# ✅ 正确：区分已平仓和未平仓

if 已平仓:
    # 已平仓：包括平仓时间和数量
    key = f"{币种}_{方向}_{开仓时间}_{平仓时间}_{数量}"
    # 允许同一开仓有多条不同平仓时间的记录
else:
    # 未平仓：只看开仓信息
    key = f"{币种}_{方向}_{开仓时间}_{开仓价格}"
    # 未平仓的持仓应该是唯一的
```

### 判断规则

#### 规则1: 已平仓记录

只有当**所有关键信息完全相同**时才是重复：
- 币种相同
- 方向相同
- 开仓时间相同
- **平仓时间相同**
- **数量相同**

#### 规则2: 未平仓记录

当**开仓信息完全相同**时才是重复：
- 币种相同
- 方向相同
- 开仓时间相同
- 开仓价格相同

#### 规则3: 分批止盈识别

如果多条记录：
- 币种、方向、开仓时间相同
- 但平仓时间不同
- → 这是**分批止盈**，不是重复

## 📋 工具更新

### 1. check_trades_format.py

```bash
python3 check_trades_format.py
```

**新增输出**：
```
🔄 检查重复记录（支持分批止盈）:
  ✓ 没有真正重复的记录
  ℹ️  发现 15 组分批止盈记录（正常）:
    BTC 多: 3 次平仓
    ETH 空: 2 次平仓
    SOL 多: 2 次平仓
    ...
```

- **真正重复**: 所有信息完全相同的记录
- **分批止盈**: 同一开仓的多次平仓（正常）

### 2. fix_all_trades.py

```bash
python3 fix_all_trades.py
```

**优化后行为**：
- ✅ 只删除真正重复的记录
- ✅ 保留分批止盈的所有记录
- ✅ 显示删除和保留的统计

**输出示例**：
```
【步骤2】删除重复记录（支持分批止盈）...
  - 删除重复: BTC 多 @2025-11-20 12:00:00
  - 删除重复: ETH 空 @2025-11-20 14:30:00
✓ 删除了 5 条真正重复的记录
✓ 保留了分批止盈的多条记录
```

### 3. restore_from_binance_papi.py

从币安恢复时，使用更精确的匹配：
- 检查 开仓时间 + 开仓价格
- 避免误判已有的分批止盈记录

## 🧪 测试案例

### 案例1: 正常分批止盈

**CSV内容**：
```csv
开仓时间,平仓时间,币种,方向,数量,开仓价格,平仓价格,盈亏(U)
2025-11-20 10:00:00,2025-11-20 12:00:00,BTC,多,0.003,92000,93500,4.5
2025-11-20 10:00:00,2025-11-20 14:00:00,BTC,多,0.003,92000,94200,6.6
2025-11-20 10:00:00,2025-11-20 16:00:00,BTC,多,0.004,92000,95000,12.0
```

**检查结果**：
```
✓ 没有真正重复的记录
ℹ️  发现 1 组分批止盈记录（正常）:
  BTC 多: 3 次平仓
```

**修复结果**：
- ✅ 3条记录全部保留
- 总盈亏：23.1 USDT

### 案例2: 真正的重复

**CSV内容**：
```csv
开仓时间,平仓时间,币种,方向,数量,开仓价格,平仓价格,盈亏(U)
2025-11-20 10:00:00,2025-11-20 12:00:00,BTC,多,0.003,92000,93500,4.5
2025-11-20 10:00:00,2025-11-20 12:00:00,BTC,多,0.003,92000,93500,4.5
```

**检查结果**：
```
⚠️  发现 1 组真正重复的记录:
  #1 和 #2: BTC 多 @2025-11-20 12:00:00
```

**修复结果**：
- ✅ 删除1条重复
- ✅ 保留1条原始记录

### 案例3: 混合情况

**CSV内容**：
```csv
# 分批止盈 (正常)
2025-11-20 10:00:00,2025-11-20 12:00:00,BTC,多,0.003,92000,93500,4.5
2025-11-20 10:00:00,2025-11-20 14:00:00,BTC,多,0.003,92000,94200,6.6

# 重复记录 (错误)
2025-11-20 10:00:00,2025-11-20 14:00:00,BTC,多,0.003,92000,94200,6.6

# 另一个开仓 (正常)
2025-11-20 15:00:00,2025-11-20 16:00:00,BTC,多,0.005,93000,94000,5.0
```

**检查结果**：
```
⚠️  发现 1 组真正重复的记录:
  #2 和 #3: BTC 多 @2025-11-20 14:00:00
ℹ️  发现 1 组分批止盈记录（正常）:
  BTC 多: 2 次平仓
```

**修复结果**：
- ✅ 删除1条重复（#3）
- ✅ 保留分批止盈的2条（#1, #2）
- ✅ 保留另一个开仓（#4）
- 最终：3条记录

## 📊 统计影响

### 总盈亏计算

**分批止盈**时，总盈亏是**所有批次的累加**：

```python
# 示例：3次分批止盈
总盈亏 = 4.5 + 6.6 + 12.0 = 23.1 USDT
```

前端显示：
- **交易历史**: 显示3条记录（每次平仓一条）
- **总盈亏**: 23.1 USDT（自动累加）
- **胜率**: 3/3 = 100%（如果都盈利）

### 如果错误删除分批止盈记录

❌ **后果**：
```
删除前：3条记录，总盈亏 = 23.1 USDT
误删2条后：1条记录，总盈亏 = 4.5 USDT
损失: 18.6 USDT 的统计数据
```

## 🔧 手动检查分批止盈

如果需要手动验证：

```bash
cd /root/10-23-bot/ds

# 查找可能的分批止盈记录
python3 << 'EOF'
import csv
from collections import defaultdict

trades_file = "trading_data/deepseek/trades_history.csv"

with open(trades_file, 'r', encoding='utf-8') as f:
    reader = csv.DictReader(f)
    trades = list(reader)

# 按开仓时间分组
groups = defaultdict(list)
for t in trades:
    if t.get('平仓时间'):  # 只看已平仓的
        key = f"{t['币种']}_{t['方向']}_{t['开仓时间']}"
        groups[key].append(t)

# 显示分批止盈的
print("分批止盈记录:")
for key, records in groups.items():
    if len(records) > 1:
        parts = key.split('_')
        total_pnl = sum(float(r.get('盈亏(U)', 0) or 0) for r in records)
        print(f"\n{parts[0]} {parts[1]} @{parts[2]}:")
        print(f"  共 {len(records)} 次平仓，总盈亏: {total_pnl:.2f} USDT")
        for i, r in enumerate(records, 1):
            print(f"    批次{i}: {r['平仓时间']} | 数量:{r['数量']} | 盈亏:{r['盈亏(U)']} USDT")
EOF
```

## 💡 最佳实践

1. **恢复数据前先检查**
   ```bash
   python3 check_trades_format.py  # 查看是否有分批止盈
   ```

2. **使用新版工具**
   ```bash
   python3 fix_all_trades.py  # 会正确保留分批止盈
   ```

3. **验证修复结果**
   ```bash
   # 检查分批止盈是否保留
   python3 check_trades_format.py
   
   # 查看最终统计
   cd /root/10-23-bot/ds/trading_data/deepseek
   # 手动计算总盈亏，验证是否正确
   ```

4. **定期备份**
   ```bash
   # 修复前总是先备份
   cp trades_history.csv trades_history.csv.backup_$(date +%Y%m%d)
   ```

## 🎯 总结

| 场景 | 特征 | 处理方式 |
|-----|------|---------|
| 分批止盈 | 开仓相同，平仓时间不同 | ✅ 保留所有记录 |
| 真正重复 | 所有字段完全相同 | ❌ 删除重复 |
| 未平仓重复 | 开仓信息完全相同 | ❌ 删除重复 |

**核心原则**：
> 只有当所有关键信息（包括平仓时间和数量）都完全相同时，才认为是真正的重复记录。

---

**版本**: V2.0  
**更新**: 2025-11-20  
**支持**: 分批止盈机制

